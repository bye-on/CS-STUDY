# HTTP/3

## 1. HTTP/3의 등장 배경

HTTP/3를 이해하기 위해서는 이전 버전들이 가졌던 구조적 한계점을 먼저 파악해야 합니다.

### 1.1 HTTP/1.1의 한계: 단순함의 대가

초기 웹을 지배한 HTTP/1.1은 구조가 단순했지만 효율성 측면에서 치명적인 단점이 있었습니다.

- **Connection당 1개 요청:** 하나의 TCP 연결로 한 번에 하나의 파일(HTML, CSS, JS 등)만 요청하고 응답받을 수 있었습니다.
- **HOLB (Head-of-Line Blocking):** 가장 앞선 요청(예: main.css)의 처리가 늦어지면, 그 뒤의 모든 요청(이미지, 스크립트)이 앞차가 빠지기만을 하염없이 기다려야 했습니다.
- **브라우저의 꼼수:** 이를 해결하기 위해 브라우저는 도메인당 6~8개의 TCP 연결을 동시에 맺는 방식을 사용했지만, 이는 네트워크 자원을 불필요하게 소모하는 미봉책이었습니다.

### 1.2 HTTP/2의 시도: 멀티플렉싱과 새로운 한계

HTTP/2는 HTTP/1.1의 문제를 해결하기 위해 스트림 기반 멀티플렉싱(Stream Multiplexing)을 도입했습니다.

- **개선점:** 단 하나의 TCP 연결 안(터널)에 여러 개의 논리적 스트림을 만들어, 데이터 순서에 상관없이 여러 파일을 동시에 주고받을 수 있게 되었습니다. 애플리케이션 계층(HTTP)에서의 줄 서기 문제(HOLB)는 해결되었습니다.
- **새로운 문제 (TCP의 HOLB):** 하지만 더 근본적인 문제가 발생했습니다. HTTP/2는 여전히 TCP 위에서 동작하기 때문입니다.
    - TCP는 모든 데이터의 **순서 보장**을 생명처럼 여깁니다.
    - 만약 하나의 패킷(예: 2번 패킷)이 유실되면, TCP는 그 패킷이 재전송되어 도착할 때까지 뒤에 도착한 정상 패킷(3번, 4번...)들을 애플리케이션에 넘겨주지 않고 대기시킵니다.
    - 결과적으로 패킷 하나가 유실되었을 뿐인데, 해당 패킷과 전혀 상관없는 다른 스트림의 데이터까지 모두 처리가 지연되는 **TCP 계층의 HOLB**가 발생했습니다.

### 1.3 느린 연결 수립 속도 (Handshake Overhead)

TCP와 TLS(보안 계층)가 분리되어 있어 초기 연결 시 불필요한 왕복 시간이 소요됩니다.

- **TCP 3-Way Handshake (1-RTT)**
- **TLS Handshake (1-RTT)**
- 총 2-RTT(왕복)가 지나야 실제 데이터를 보낼 수 있어, 모바일 환경처럼 지연 시간이 긴 곳에서는 체감 속도가 느려집니다.

---

## 2. HTTP/3란 무엇인가?

### 2.1 정의: HTTP over QUIC

HTTP/3는 전송 계층 프로토콜로 **TCP를 더 이상 사용하지 않습니다.** 대신 Google이 개발하고 IETF가 표준화한 **QUIC(Quick UDP Internet Connections)** 프로토콜 위에서 동작합니다.

### 2.2 핵심 변화: TCP에서 UDP로

가장 큰 변화는 기반 프로토콜이 **신뢰성 있는 TCP**에서 **신뢰성 없는 UDP**로 바뀌었다는 점입니다.

- **의문점:** 신뢰성이 생명인 웹 통신에 어떻게 데이터 유실을 허용하는 UDP를 사용할 수 있는가?
- **해결책:** UDP 자체는 단순히 데이터를 던져주는 역할만 하고, 신뢰성 보장(순서 맞추기, 재전송, 흐름 제어)과 보안(TLS) 기능을 **QUIC**이라는 프로토콜이 **애플리케이션 레벨(User-space)**에서 직접 구현했기 때문입니다.

---

## 3. 구조적 혁명: User-space vs Kernel-space

HTTP/3가 혁신적인 이유는 프로토콜이 구동되는 위치가 OS 커널에서 사용자 애플리케이션으로 이동했기 때문입니다.

### 3.1 기존 TCP의 구조 (Kernel-space)

- TCP 프로토콜은 **운영체제 커널 안**에 구현되어 있습니다.
- 애플리케이션(브라우저)은 커널에게 데이터를 보내달라고 요청만 할 수 있을 뿐, 전송 방식을 제어할 수 없습니다.
- 커널은 모든 데이터를 **하나의 줄**로 세워 관리하므로, 중간에 하나가 비면 전체를 멈추는 경직된 방식으로 동작합니다.

### 3.2 QUIC의 구조 (User-space)

- QUIC은 운영체제 커널이 아닌, 브라우저나 웹 서버 같은 **애플리케이션 내부(User-space)**에 구현됩니다.
- **커널의 역할 축소:** 커널에게는 UDP 소켓을 열어달라고만 하고, 데이터를 목적지로 쏘는 단순 배달부 역할만 맡깁니다.
- **애플리케이션의 주도권:** 패킷의 순서를 맞추거나, 유실된 패킷을 재전송하는 판단을 애플리케이션이 직접 수행합니다. 이를 통해 스트림별로 **독립적인 통신 제어**가 가능해집니다.

---

## 4. 상세 통신 흐름 시뮬레이션: 패킷 유실 시

서버가 클라이언트에게 3개의 데이터(**스트림 1: CSS**, **스트림 2: JS**, **스트림 3: IMG**)를 보낼 때, **2번 패킷(JS)이 유실된 상황**을 가정하여 비교합니다.

### 4.1 HTTP/2 + TCP (커널 주도형 통신)

1. **전송:** 서버 커널(TCP)이 1, 2, 3번 패킷을 순서대로 보냅니다.
2. **사고 발생:** 네트워크 상에서 **2번 패킷이 유실**됩니다.
3. **수신 (클라이언트 커널):**
    - 1번 패킷 도착.
    - 3번 패킷 도착.
    - **커널 판단:** 1번은 왔는데 2번이 안 왔으므로, 순서가 틀렸다. **2번이 올 때까지 3번은 애플리케이션(브라우저)에 주지 않고 버퍼에 가둔다.**
4. **재전송 대기:** 브라우저는 3번(IMG) 데이터가 이미 도착했음에도 불구하고, 2번 때문에 받지 못하고 렌더링을 멈춥니다 (**Blocking**).

### 4.2 HTTP/3 + QUIC (앱 주도형 통신)

1. **전송:** 서버 애플리케이션(QUIC)이 1, 2, 3번 패킷을 만들고 커널(UDP)을 통해 보냅니다.
2. **사고 발생:** 네트워크 상에서 **2번 패킷이 유실**됩니다.
3. **수신 (클라이언트 커널):** UDP는 순서를 신경 쓰지 않으므로 1번과 3번 패킷을 받는 즉시 애플리케이션(QUIC)으로 던져줍니다.
4. **처리 (클라이언트 애플리케이션):**
    - **QUIC 라이브러리:** 1번(CSS) 도착했네? **브라우저 엔진에 전달.**
    - **QUIC 라이브러리:** 3번(IMG) 도착했네? 이건 2번이랑 상관없는 다른 스트림이니까 **브라우저 엔진에 전달.**
    - **QUIC 라이브러리:** 2번이 비었네? 서버에 **2번만 다시 보내달라고 요청.**
5. **결과:** 유실된 2번(JS)을 제외한 CSS와 이미지는 **즉시 화면에 렌더링**됩니다. 전체 멈춤 현상이 사라집니다.

---

## 5. HTTP/3의 핵심 기능 요약

### 5.1 독립적인 스트림 멀티플렉싱

위 시뮬레이션에서 본 것처럼, QUIC은 각 스트림을 독립적으로 다룹니다. 한 스트림의 패킷 유실이 다른 스트림에 영향을 주지 않아 **진정한 의미의 병렬 처리**가 가능합니다.

### 5.2 더 빠른 연결 (1-RTT & 0-RTT)

- TCP+TLS는 연결에 2번의 왕복이 필요했지만, QUIC은 **TLS 1.3을 내장**하여 1번의 왕복(1-RTT)만으로 연결을 수립합니다.
- 한 번 연결했던 서버에는 **0-RTT(즉시 데이터 전송)** 재접속을 지원하여 초기 로딩 속도를 획기적으로 줄입니다.

### 5.3 연결 마이그레이션 (Connection Migration)

- TCP는 IP 주소가 바뀌면 연결이 끊어집니다 (Wi-Fi에서 LTE로 전환 시).
- QUIC은 Connection ID(CID)라는 고유 식별자를 사용하여 통신합니다. 사용자의 IP가 바뀌어도 CID가 같다면 서버는 연결을 유지합니다. 모바일 환경에서 **끊김 없는 통신**을 제공합니다.

---

## 6. 실전 적용 및 확인 방법

### 6.1 서버 적용 가이드

HTTP/3를 적용하기 위해서는 반드시 **UDP 443 포트**를 방화벽에서 열어야 합니다.

- **Nginx:** 최신 버전(1.25.0 이상)에서 설정 가능.
- **Cloudflare:** 대시보드 Network 탭에서 HTTP/3 옵션을 켜는 것만으로 즉시 적용 가능 (가장 추천하는 방법).
- **주의사항:** AWS 보안 그룹 등에서 TCP 443만 열려있고 UDP 443이 막혀있으면 HTTP/3로 접속되지 않습니다.

### 6.2 적용 확인 방법

- **Chrome 개발자 도구:** Network 탭에서 Protocol 컬럼을 확인했을 때 `h3`라고 표시되면 HTTP/3로 통신 중인 것입니다.
- **Alt-Svc 헤더:** 응답 헤더에 `Alt-Svc: h3=":443"` 내용이 있다면, 서버가 클라이언트에게 "다음부터는 HTTP/3로 접속하라"고 알리는 신호입니다.

---