# HTTP / 2

> SPDY 프로토콜에서 파생된 HTTP/1.x 보다 지연 시간을 줄이고 응답 시간을 더 빠르게 할 수 있으며 멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리를 지원하는 프로토콜이다.
> 

### 멀티 플렉싱

- 여러 개의 스트림을 사용하여 송수신한다는 것.
- 이를 통해 특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림은 멀쩡하게 동작할 수 있다.
- 하나의 연결 안에서 여러 요청/ 응답을 처리하는 방식이다.

<aside>
💡

스트림(Stream)

- 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 데이터 흐름
</aside>

<aside>
💡

특정 스트림 패킷이 손실되어도 나머지 스트림은 멀쩡하게 동작할 수 있는 이유

TCP : 실제 패킷은 순서 보장, segment 단위로 전달

HTTP 2 는 여러 요청 데이터를 frame 단위로 나눠서 스트림별 번호를 tagging 해서 보내기 때문에 패킷이 오더라도 각각이 어떤 stream 에 속했는지 구분이 된다.

> 논리적으로 분리되어 있기 때문에 영향이 개별 스트림에 한정해서 보인다.

</aside>

![image.png](HTTP%202/image.png)

- 하나의 연결 내 여러 스트림을 캡처한 모습.
- 병렬적인 스트림들을 통해 데이터를 서빙하고 있다. 스트림 내의 데이터들도 쪼개져 있다.
- 애플리케이션에서 받아온 메시지를 독립된 프레임으로 조각내어 서로 송수신한 이후 다시 조립하여 데이터를 주고 받는다.

![image.png](HTTP%202/image%201.png)

→ 보기와 같이 하나의 TCP 연결 안에 여러개의 응답 요청을 한방에 처리하는 방식

- 이렇게 되면 단일 연결을 사용하여 병렬로 여러 요처응ㄹ 받을 수 있고 응답을 줄 수 있다.
- 이렇게 되면 1.x 에서 발생하는 문제인 HOL Blocking을 해결할 수 있다.

### 헤더 압축

![image.png](HTTP%202/image%202.png)

- HTTP 1.x 에서는 헤더의 크기가 크다라는 단점을 가지고 있는데 2에서는 헤더 압축을 써서 해결한다.
- 허프만 코딩 압축 알고리즘을 사용하는 HPACK 압축 형식을 가진다.

### 허프만 코딩

> 등장 빈도가 높은 문자일수록 더 짧은 bit로 표현하고
등장 빈도가 낮은 문자일수록 더 긴 bit 로 표현하는 가변 길이 인코딩 방식
> 

<aside>
💡

자주 쓰이는 문자는 빨게, 드물게 쓰이는 문자는 길게

</aside>

> 그런데 왜 허프만이 효과적인가?
> 

HTTP header 문자는 특정 패턴이 많고 알파벳 편중이 심함.
→ 이러한 이유 때문에 허프만과 매우 잘 맞다라는 특징이 있었음

### 서버 푸시

HTTP/ 1.1 에서는 클라이언트가 서버에 요청을 해야 파일을 다운로드 받을 수 있었다면,

HTTP/2는 클라이언트 요청 없이 서버가 바로 리소스를 푸시할 수 있다.

<aside>
💡

1.1 에서 서버 푸시가 불가능 했던 이유.

request → response 1:1 구조 였기 때문이다.
클라이언트가 요청을 보내야만 서버가 응답을 보낼 수 있는 구조이기 때문에 서버는 먼저 보낼 권한이 없다.

즉, 항상 클라이언트 요청이 트리거가 되어야만 응답이 발생한다.

그래서 서버가
”너 이거도 필요할 것 같아서 미리 보내줄게!”
라는 Push 개념이 구조적으로 불가능하다.

</aside>

![image.png](HTTP%202/image%203.png)

- Html 에는 css 나 js 파일이 포함되기 마련인데 html을 읽으면서 그 안에 들어 있던 css을 서버에서 푸시하여 클라이언트에 먼저 줄 수 있다.