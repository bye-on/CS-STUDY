## 1. 물리적 메모리 할당

<img src="images/image%206.png" width="200" height="300">

### 1.1 사용자 프로세스 영역 할당 방법

#### Contiguous Allocation (연속 할당)

각 프로세스가 메모리의 연속적인 공간에 적재

- Fixed Partition Allocation (고정 분할)
- Variable Partition Allocation (가변 분할)  

**고정 분할 vs 가변 분할:**

| 구분 | 고정 분할 | 가변 분할 |
|------|----------|----------|
| 분할 방식 | 미리 나눔 | 동적으로 결정 |
| Internal Fragmentation | O | X |
| External Fragmentation | O | O |

#### Noncontiguous Allocation (불연속 할당)

하나의 프로세스가 메모리의 여러 영역에 분산되어 올라감

- Paging
- Segmentation
- Paged Segmentation

## 2. 연속 할당 (Contiguous Allocation) - 고정 분할 (Fixed Partition)

<img src="images/image%207.png" width="700">

- 물리적 메모리를 몇 개의 **영구적 partition**으로 미리 나눔
- 분할 크기가 모두 동일하거나 서로 다를 수 있음
- 분할 당 하나의 프로그램 적재

**단점:**
- 융통성 없음
- 동시에 메모리에 load되는 프로그램 수가 고정됨
- 최대 수행 가능 프로그램 크기 제한
- **Internal Fragmentation** 발생

**:small_orange_diamond: Internal Fragmentation (내부 조각):**
- 프로그램 크기가 partition보다 작을 때 partition 내부에 남는 공간
- 예: 10MB partition에 7MB 프로그램 → 3MB 낭비

## 3. 연속 할당 (Contiguous Allocation) - 가변 분할 (Variable Partition)

- 프로그램 크기를 고려해서 할당
- 분할의 크기, 개수가 동적으로 변함
- 프로그램이 실행되면 순서대로 메모리에 빈칸없이 올림

**문제점:**
- 프로그램 종료 시 빈 공간 발생
- 빈 공간보다 큰 프로그램은 올릴 수 없어 메모리 낭비 발생
- **External Fragmentation** 발생

**:small_orange_diamond: External Fragmentation (외부 조각):**
- Partition들 사이에 생기는 작은 빈 공간
- 작은 partition들이 남아 큰 프로그램을 올릴 수 없음

### 3.1 Dynamic Storage-Allocation Problem

가변 분할 방식에서 size n인 요청을 만족하는 가장 적절한 hole(가용 메모리 공간)을 찾는 문제

#### 1) First-fit
- Size가 n 이상인 것 중 **최초로 찾아지는 hole**에 할당
- 장점: 빠른 결정으로 시간 효율적

#### 2) Best-fit
- Size가 n 이상인 **가장 작은 hole**을 찾아서 할당
- 단점: 
  - 모든 hole 리스트를 탐색해야 하는 오버헤드
  - 매우 작은 hole들이 많이 생성됨

#### 3) Worst-fit
- **가장 큰 hole**에 할당
- 단점: 모든 리스트를 탐색해야 함
- 장점: 상대적으로 큰 hole들이 생성됨

### 3.2 Compaction
빈 공간을 모아서 큰 공간으로 만드는 작업  
-> 빈 공간이 있음에도 활용이 안될 때 취할 수 있는 방법이다.
<img src="images/image%208.png" width="700">

외부 단편 문제를 해결하는 방법

- 사용 중인 메모리 영역을 한 군데로 몰고 hole들을 다른 한 곳으로 모아 큰 block 생성
- **매우 비용이 많이 드는 방법**
- 최소한의 메모리 이동으로 compaction하는 방법은 매우 복잡한 문제
- **Execution Time Binding**이 지원되는 경우에만 수행 가능

## 4. 불연속 할당 - 페이징 (Paging) 

<img src="images/image%209.png" width="400" height="400">

### 4.1 기본 개념

- 프로세스의 가상 메모리를 **동일한 크기의 page 단위**로 나눔
- 가상 메모리의 내용이 page 단위로 물리적 메모리에 불연속적으로 저장됨
- 일부는 backing storage에, 일부는 physical memory에 저장

**Basic Method:**

- Physical memory를 동일한 크기의 **frame**으로 나눔
- Logical memory를 동일한 크기의 **page**로 나눔 (frame과 같은 크기)
- Page table을 사용하여 논리적 주소를 물리적 주소로 변환
- **External Fragmentation 발생 안 함** (모든 page 크기가 동일하므로)
- **Internal Fragmentation 발생 가능** (마지막 page가 frame을 다 채우지 못할 수 있음)

<img src="images/image%2010.png" width="400" height="400">  

**Page Table의 구성:**

- 프로세스의 page 개수만큼 entry 존재
- 각 entry에는 해당 page가 위치한 frame number 저장
- **Valid-invalid bit**로 page가 메모리에 있는지 표시
  - Valid: 해당 page가 물리적 메모리에 있음
  - Invalid: 해당 page가 메모리에 없음 (디스크에 있음)

### 4.2 주소 변환

<img src="images/image%2011.png" width="400" height="400">

CPU가 보는 논리적 주소는 두 부분으로 구성:

- **Page number (p)**: Page table의 인덱스
- **Page offset (d)**: Page 내에서의 위치

**주소 변환 과정:**

1. CPU가 논리적 주소 제공
2. Page number로 page table 접근
3. Page table에서 frame number 획득
4. Frame number + offset = 물리적 주소

### 4.3 Page Table 구현

**Page table은 main memory에 상주**

- **Page-table Base Register (PTBR)**: Page table의 시작 위치
- **Page-table Length Register (PTLR)**: Page table의 크기

**문제점:** 모든 메모리 접근에 **2번의 memory access** 필요

1. Page table 접근 (주소 변환)
2. 실제 데이터 접근

**해결책:** TLB (Translation Look-aside Buffer) 사용

#### TLB (Translation Look-aside Buffer)
주소 변환을 빠르게 하기 위한 **고속 캐시 메모리**  

<img src="images/image%2012.png" width="450" height="400">

**동작 과정:**

1. CPU가 논리적 주소 제공
2. TLB에서 먼저 검색 (병렬 검색)
3. **TLB hit**: 바로 frame number 획득 → 메모리 접근 1번
4. **TLB miss**: Page table에서 주소 변환 → 메모리 접근 2번

**Page Table vs TLB:**

| 구분 | Page Table | TLB |
|------|-----------|-----|
| 저장 내용 | Frame number만 | Page number + Frame number |
| 검색 방식 | 인덱스로 직접 접근 | 전체 검색 (병렬) |
| 위치 | 메모리 | 캐시 |
| 크기 | 큼 (모든 page) | 작음 (일부만) |

**TLB는 Associative Register**로 구현되어 병렬 검색 가능
- Associative Register : 병렬적으로 찾는 것이 가능한 하드웨어 

**Context Switch 시 (CPU가 다른 프로세스로 넘어갔을 때):**
- 프로세스마다 page table이 다르므로 TLB 내용을 비워 함
- Context switch의 오버헤드 중 하나

### 4.4 Two-Level Page Table
프로그램의 주소 공간은 Code, Data, Stack으로 구성되어 있고 그 중간에는 사용되지 않는 논리주소가 상당 부분을 차지하고 있다.  
페이지 테이블은 인덱스를 통해 접근하기 때문에 주소 공간 중간에 구멍이 있다고 해서 그 Entry를 빼고 만들 수 없다.  
 
Two-Level Page Table은 CPU가 논리적 주소를 주게 되면 페이지 테이블은 두 단계를 거쳐서 주소 변환을 하고 그다음 실제 메모리에 접근한다.
Page table 자체를 Page로 구성하여 사용되지 않는 주소 공간에 대한 바깥쪽 Outer page table의 Entry값은 NULL으로 저장한다. (대응하는 Inner page table이 없음)

<img src="images/image%2013.png" width="400" height="500">
<img src="images/image%2014.png" width="400">

**핵심 아이디어:** Page table 자체를 page로 구성

- 사용되지 않는 주소 공간의 경우 outer page table의 entry는 NULL
- 대응하는 inner page table이 만들어지지 않음

**주소 변환 과정:**

1. 논리적 주소를 outer page, inner page, offset으로 분리
2. Outer page table 접근
3. Inner page table 접근
4. Frame number 획득
5. 물리적 주소 생성

**장단점:**

- 장점: 공간 절약 (사용하지 않는 영역의 inner table은 생성 안 함)
- 단점: 주소 변환 시 메모리 접근 횟수 증가 (2번 → 3번)

### 4.5 Memory Protection

Page table의 각 entry에 추가 bit 사용:

#### Protection Bit

Page에 대한 접근 권한 설정

- Read/Write/Read-only
- Execute 권한 등

**예시:**
- Code 영역: Read + Execute
- Data 영역: Read + Write
- Stack 영역: Read + Write

#### Valid-Invalid Bit

- **Valid**: 해당 frame에 프로세스의 유효한 내용이 있음 (접근 허용)
- **Invalid**: 해당 frame에 유효한 내용이 없음 (접근 불허)
  - 메모리에 없거나 (디스크에 있음)
  - 프로세스가 사용하지 않는 주소 영역

### 4.6 Inverted Page Table

<img src="images/image%2015.png" width="500" height="400">

### 기존 Page Table의 문제

- 모든 프로세스별로 모든 논리적 주소에 대한 entry 존재
- 메모리에 있든 없든 page table에 entry 필요
- 공간 낭비 심각

#### Inverted Page Table 구조
물리 메모리를 그대로 사상하고 있으며, 모든 프로세스가 하나의 페이지 테이블을 참조한다.  
그렇기 때문에 페이지 테이블의 entry 개수는 물리 메모리의 frame 개수와 동일하며 고정되어 있다는 점이 특징이다.  
모든 프로세스가 역페이지 테이블을 참조하기 때문에, 어떤 프로세스의 사상 정보를 가지고 있는지 구분하기 위해 pid를 사용하여 참조한다.  

**핵심 아이디어:** Physical memory의 frame 개수만큼만 entry 생성  

- **System-wide:** 시스템에 page table이 하나만 존재
- 각 entry는 (process-id, logical page number) 저장
- Frame number = Entry의 index

**주소 변환 과정:**

1. CPU가 (pid, p, d) 제공
2. Page table 전체를 탐색하여 (pid, p) 찾기
3. 찾은 entry의 index = frame number
4. Frame number + offset = 물리적 주소

**장단점:**

- 장점: 공간 절약 (frame 개수만큼만 entry)
- 단점: 테이블 전체를 탐색해야 하는 오버헤드
- 해결: **Associative register** 사용 (병렬 검색)

### 4.7 Shared Page  
여러 개의 프로세스가 동일한 프로그램 코드를 실행하지만, 각 프로세스마다 사용하는 데이터는 서로 다르다.  
만약 동일한 코드를 각 프로세스가 각자 물리 메모리에 적재하면 동일한 코드가 여러 번 올라가 메모리가 낭비된다.  

이를 해결하기 위해, 코드가 실행 중에 변경되지 않는 경우(Re-entrant Code) 하나의 코드 영역을 여러 프로세스가 **공유(Shared Code)**할 수 있다.  
이게 바로 Shared Page 기법이다.  
<img src="images/image%2016.png" width="500" height="400">

#### Shared Code

**Re-entrant Code (Pure Code): 실행 중에 변하지 않는 코드**
Re-entrant code는 프로세스가 읽기만 하는 순수 코드이기 때문에, 여러 프로세스가 동시에 사용해도 충돌이 없다.  

- 코드 영역을 Read-only로 설정하여 모든 프로세스가 하나의 사본을 공유
- 예: text editors, compilers, window systems
- **모든 프로세스의 logical address space에서 동일한 위치에 있어야 함** → 공유하기 위해 같은 가상주소에 매핑되어야 함

**장점:**
- 동일한 프로그램을 여러 번 실행해도 code는 메모리에 1번만 올라감
- 메모리 절약

#### Private Code and Data

- 각 프로세스는 code와 data를 독자적으로 메모리에 올림
- Private data는 logical address space의 아무 곳에 와도 무방 → 공유할 필요 없기 때문  

## 5. 불연속 할당 - 세그멘테이션 (Segmentation)

### 5.1 기본 개념

프로그램을 **의미 단위**인 여러 개의 segment로 구성

**Segment 단위:**
- 작게: 함수 하나하나
- 크게: 프로그램 전체
- 일반적: code, data, stack 각각 하나의 segment

**Logical Unit 예시:**
- main()
- function
- global variables
- stack
- symbol table
- arrays

### 5.2 Segmentation Architecture

<img src="images/image%2017.png" width="500" height="400">
<img src="images/image%2018.png" width="500" height="400">

**Logical Address:** `<segment-number, offset>`

**Segment Table:**
- **Base**: Segment의 물리적 메모리 시작 주소 (byte 단위)
- **Limit**: Segment의 길이

**레지스터:**
- **STBR (Segment-table Base Register)**: Segment table의 물리적 메모리 위치
- **STLR (Segment-table Length Register)**: 프로그램이 사용하는 segment 수

**주소 변환 과정:**

1. Segment number가 STLR보다 작은지 확인
2. Offset이 segment limit보다 작은지 확인
3. Base + offset = 물리적 주소

**Paging과의 차이:**

| 구분 | Paging | Segmentation |
|------|--------|--------------|
| 분할 단위 | 동일한 크기 | 의미 단위 (크기 다름) |
| 주소 표현 | Frame number | Byte 단위 base address |
| External Fragmentation | 없음 | 발생 |
| 장점 | 구현 간단 | 의미 단위로 보호/공유 용이 |

### 5.3 Protection과 Sharing
Segmentation은 프로그램을 **의미 단위(코드, 데이터, 스택 등)**로 나누기 때문에  
**보안(Protection)과 공유(Sharing) 측면에서 Paging보다 훨씬 더 유리하다.**

**Protection:**
Segmentation에서는 각 Segment마다 별도로 보호 권한을 설정할 수 있다.

Protection 구성 요소  
1) Valid bit  
   Valid bit = 0 → 접근이 허용되지 않은 illegal segment  
   Valid bit = 1 → 정상적인 segment  

2) 권한 비트 (Read/Write/Execute)
   Segment마다 다음과 같은 권한을 부여할 수 있다.
   - Code segment: Read + Execute
   - Data segment: Read + Write
   - Stack segment: Read + Write

**Sharing:**

<img src="images/image%2019.png" width="400" height="500">

프로세스들이 같은 Segment를 공유하려면 다음 조건을 만족해야 한다.  
- Shared segment는 같은 segment number를 가져야 함
- 동일한 물리적 주소로 변환되어야 
- Base(시작 주소)와 Limit(크기)도 동일해야 함

즉, 서로 다른 프로세스가 같은 “코드 segment”라고 인식해야 동일한 물리 메모리를 참조하게 된다. 

**왜 Segment는 Paging보다 Protection/Sharing에서 더 효과적인가?**
Segment는 기능적 의미 단위로 나누기 때문에  
1. 코드만 읽기 전용으로 만들기 쉽고
2. 데이터만 쓰기 가능으로 설정하기 쉽고
3. 스택 영역만 별도로 보호하기도 쉽다.

Paging은 단순한 블록으로 나누기 때문에  
1. 어떤 page가 코드인지 데이터인지 명확하지 않음
2. 의미 없는 단위라서 보호·공유 정책을 의미 단위로 적용하기 어려움

**Paging vs Segmentation:**

| 항목 | Paging | Segmentation |
|------|--------|--------------|
| Entry 수 | 매우 많음 (100만 개 이상) | 적음 (수십 개) |
| Table 크기 | 큰 공간 낭비 | 작음 |
| External Fragmentation | 없음 | 있음 |
| 의미 단위 관리 | 어려움 | 쉬움 |

## 6. 불연속 할당 - Segmentation with Paging

<img src="images/image%2020.png" width="500" height="400">

### 6.1 기본 개념

**Pure Segmentation과의 차이:**

- Segment-table entry가 segment의 base address를 가지는 것이 아님
- **Segment를 구성하는 page table의 base address**를 가짐

**동작 방식:**

1. 기본적으로 segmentation 기법 사용
2. 각 segment를 page로 분할
3. Page 단위로 물리적 메모리에 올림
4. 물리적 메모리는 동일한 크기의 page frame으로 관리

### 6.2 주소 변환

**논리적 주소:** `<segment-number, offset>`

**Offset 구성:** `<page-number, page-offset>`

**주소 변환 과정:**

1. Segment number로 segment table 접근
2. Segment table에서 해당 segment의 page table 위치 획득
3. Page number로 page table 접근
4. Frame number 획득
5. Frame number + page offset = 물리적 주소

**예시:**

- 1번 segment: 3개의 page로 구성
- 2번 segment: 5개의 page로 구성
- Segment 길이는 page의 배수

**Page Table:**

- 프로세스마다 존재하는 것이 아님
- **Segment마다 존재**
- 예: Segment가 10개의 page로 구성 → Page table entry 10개

### 6.3 장점

1. **의미 단위 관리**: Segmentation의 장점
   - 보호(Protection) 용이
   - 공유(Sharing) 용이

2. **공간 효율**: Paging의 장점
   - External Fragmentation 없음
   - 동일한 크기로 관리

3. **메모리 관리 효율**
   - 사용하지 않는 segment의 page table은 생성하지 않음
   - Paging보다 공간 절약
