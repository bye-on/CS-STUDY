# 운영체제 가상 메모리

## 1. 가상 메모리의 기본 개념

물리적 메모리의 주소 변환은 운영체제가 관여하지 않는다. 하지만 **가상 메모리(Virtual Memory) 기법은 운영체제가 관여한다.**

## 2. Demand Paging (요구 페이징)

### 2.1 개념

필요할 때 page를 메모리에 올리는 기법

**장점:**
- I/O 양 감소
- 메모리 사용량 감소
- 빠른 응답 시간
- 더 많은 사용자 수용 가능

### 2.2 Valid / Invalid Bit

**Invalid의 의미:**
1. 사용되지 않는 주소 영역인 경우
2. 페이지가 물리적 메모리에 없는 경우

**동작 방식:**
- 처음에는 모든 page entry가 invalid로 초기화
- 주소 변환 시 invalid bit이 설정되어 있으면 → **page fault 발생**

대부분의 프로세스는 페이징 기법을 사용한다. 프로그램이 시작될 때 프로세스를 구성하는 모든 페이지를 메모리에 올리지 않고 Demand Paging 기법을 사용한다.

### 2.3 메모리에 없는 Page의 Page Table

<img src="images/image%2021.png" width="700">

Demand Paging 기법을 사용하면 프로그램을 최초로 실행할 때 페이지 테이블에 모두 invalid로 표시된다. 페이지가 메모리에 올라가면 invalid가 valid로 바뀌면서 해당하는 페이지 번호가 entry에 적힌다.

변환하려는 주소가 invalid 상태이면 **page fault 현상**이 일어난다. 이 현상이 일어나면 CPU는 자동으로 운영체제에 넘어가고, 운영체제가 CPU를 가지고 fault 난 페이지를 메모리에 올린다.

## 3. Page Fault 처리 과정

<img src="images/image%2022.png" width="700">

### 3.1 Page Fault 발생

- Invalid page를 접근하면 MMU가 **trap**을 발생시킴 (page fault trap)
- Kernel mode로 들어가서 page fault handler가 실행됨

### 3.2 처리 순서

1. **Invalid reference 확인**: 잘못된 접근인지 확인 (bad address, protection violation)
   - 잘못된 접근이면 → 프로세스 종료 (abort process)

2. **빈 page frame 확보**: 없으면 다른 페이지를 쫓아냄 (replace)

3. **디스크에서 메모리로 페이지 읽기**
   - Disk I/O가 끝날 때까지 이 프로세스는 CPU를 빼앗김 (block 상태)
   - Disk read가 끝나면 page table entry 기록, valid/invalid bit = "valid"로 변경
   - Ready queue에 프로세스 삽입 → 나중에 dispatch

4. **프로세스 재개**: 이 프로세스가 CPU를 잡고 다시 running

5. **중단된 명령어 재개**: 아까 중단되었던 instruction을 다시 실행

## 4. Demand Paging의 성능

Page fault가 발생하면 디스크에 접근해야 하므로 오래 걸린다.  
따라서 page fault가 얼마나 자주 발생하느냐에 따라 메모리 접근 시간이 크게 좌우된다.  

**실제 상황:**
- Page fault rate은 약 0.1% 미만
- 대부분의 경우 page fault가 발생하지 않고 메모리로부터 직접 주소 변환 가능  

## 5. Page Replacement 알고리즘

### 5.1 Optimal Algorithm (최적 알고리즘)

**MIN (OPT)**: 가장 먼 미래에 참조되는 page를 replace

<img src="images/image%2023.png" width="700">

**특징:**
- 미래의 참조를 모두 안다고 가정 → **Offline algorithm**
- 실제로 사용 불가능 (미래를 알 수 없음)
- 다른 알고리즘의 성능에 대한 **upper bound** 제공
- Belady's optimal algorithm, MIN, OPT 등으로 불림

### 5.2 FIFO (First In First Out) Algorithm

**FIFO**: 먼저 들어온 페이지를 먼저 쫓아냄

<img src="images/image%2024.png" width="700">

**FIFO Anomaly (Belady's Anomaly):**
- 메모리 크기를 늘려줬는데 오히려 성능이 더 나빠지는 이상한 현상
- More frames → More page faults (예상과 반대)

### 5.3 LRU (Least Recently Used) Algorithm

**LRU**: 가장 오래 전에 참조된 페이지를 쫓아냄

<img src="images/image%2025.png" width="700">

**특징:**
- 최근에 참조된 페이지는 가까운 미래에도 참조될 가능성이 높다는 가정
- 실제로 많이 사용되는 알고리즘
- 과거 참조 시점을 기준으로 판단

### 5.4 LFU (Least Frequently Used) Algorithm

**LFU**: 참조 횟수(reference count)가 가장 적은 페이지를 쫓아냄

**최저 참조 횟수인 page가 여럿 있는 경우:**
- LFU 알고리즘 자체에서는 임의로 선정
- 성능 향상을 위해 가장 오래 전에 참조된 page를 쫓아내도록 구현 가능

**장점:**
- LRU처럼 직전 참조 시점만 보지 않고 장기적인 시간 규모를 봄
- Page의 인기도를 더 정확히 반영

**단점:**
- 참조 시점의 최근성을 반영하지 못함
- LRU보다 구현이 복잡함

## 6. 캐싱과 알고리즘 제약

### 6.1 캐싱 기법

**개념:**
- 한정된 빠른 공간(캐시)에 요청된 데이터를 저장
- 후속 요청 시 캐시로부터 직접 서비스
- 예: Paging system, Cache memory, Buffer caching, Web caching

### 6.2 캐시 운영의 시간 제약

**교체 알고리즘 시간 제약:**
- 삭제할 항목을 결정하는 데 너무 많은 시간이 걸리면 실제로 사용 불가

**Buffer caching이나 Web caching:**
- O(1)에서 O(log n) 정도까지 허용

**Paging system:**
- Page fault인 경우에만 OS가 관여
- 페이지가 이미 메모리에 있는 경우 참조 시각 등의 정보를 OS가 알 수 없음
- O(1)인 LRU의 list 조작조차 불가능
- **따라서 실제 Paging system에서는 LRU, LFU를 사용할 수 없음**

## 10. Clock Algorithm

### 10.1 기본 개념

**Clock Algorithm:**
- LRU의 근사(approximation) 알고리즘
- 다른 명칭: Second chance algorithm, NUR (Not Used Recently), NRU (Not Recently Used)

**동작 방식:**
- Reference bit을 사용하여 교체 대상 페이지 선정 (circular list)
- Reference bit가 0인 것을 찾을 때까지 포인터를 하나씩 이동
- 포인터 이동 중 reference bit 1은 모두 0으로 변경
- Reference bit이 0인 것을 찾으면 그 페이지를 교체
- 한 바퀴 되돌아와서도 (second chance) 0이면 그때 replace
- 자주 사용되는 페이지라면 second chance가 올 때 다시 1

<img src="images/image%2026.png" width="700">

**비트 의미:**
- bit = 1: 최근에 참조된 페이지
- bit = 0: 최근에 참조되지 않은 페이지

**동작 원리:**
- 모든 페이지의 사용 시점을 알 수 없으므로 비트 하나로 판단
- 0인 페이지를 쫓아냄 (가장 오래된 페이지는 아니지만 최근에 사용 안 됨)
- LRU를 근사시킬 수 있음

**하드웨어와 OS의 역할:**
- 주소 변환을 하는 하드웨어가 비트를 1로 설정
- 시계바늘처럼 포인터가 돌면서 운영체제가 1을 0으로 변경

### 10.2 Clock Algorithm의 개선

**Reference bit과 Modified bit을 함께 사용:**

- **Reference bit (Access bit) = 1**: 최근에 참조된 페이지
- **Modified bit (Dirty bit) = 1**: 최근에 변경된 페이지 (I/O를 동반하는 페이지)

Modified bit이 1인 페이지를 쫓아낼 때는 디스크에 변경 내용을 써야 하므로 0인 페이지를 우선적으로 쫓아내는 것이 효율적이다.

## 11. Paging System에서 LRU, LFU 사용 가능 여부

<img src="images/image%2027.png" width="700">

**결론: 불가능**

**이유:**
- Page fault가 발생했을 때만 운영체제가 관여
- 페이지가 이미 메모리에 있으면 하드웨어가 주소 변환을 수행
- 운영체제는 어떤 페이지가 언제 참조되었는지 알 수 없음
- 따라서 LRU, LFU를 정확히 구현할 수 없음
- Clock Algorithm으로 LRU를 근사시킴

## 12. Page Frame Allocation

### 12.1 Allocation Problem

각 process에 얼마만큼의 page frame을 할당할 것인가?  
각 프로세스는 얼마만큼의 프레임을 할당받아야 감당할만큼의 페이지 폴트를 일으키면서 전체 프로세스가 원활하게 돌아갈 수 있을까?
1) Global Replacement
2) Local Replacement

**필요성:**
- 메모리 참조 명령어 수행 시 명령어, 데이터 등 여러 페이지 동시 참조
- 명령어 수행을 위해 최소한 할당되어야 하는 frame의 수가 있음
- Loop를 구성하는 page들은 한꺼번에 allocate 되는 것이 유리
- 최소한의 allocation이 없으면 매 loop마다 page fault 발생

### 12.2 Allocation Scheme

**Equal allocation:**
- 모든 프로세스에 똑같은 개수 할당

**Proportional allocation:**
- 프로세스 크기에 비례하여 할당

**Priority allocation:**
- 프로세스의 priority에 따라 다르게 할당

## 13. Global vs Local Replacement

### 13.1 Global Replacement

프로세스의 우선 순위를 따져 각 프로세스에게 동적으로 우선 순위 할당을 한다.  

**특징:**
- Replace 시 다른 process에 할당된 frame을 빼앗아 올 수 있음
- Process별 할당량을 조절하는 또 다른 방법
- FIFO, LRU, LFU 등의 알고리즘을 global replacement로 사용 시 해당
- Working set, PFF 알고리즘 사용

**동작:**
- 전체 페이지 중 가장 오래 전에 사용된 페이지를 쫓아냄
- 어떤 프로세스의 페이지인지 상관없음
- 알고리즘 취지에 맞게 쫓아남
- 메모리를 많이 사용하는 프로그램에 페이지가 많이 할당됨
- 특정 프로그램이 메모리를 독점할 수 있음

### 13.2 Local Replacement

프로세스 별로 할당된 프레임의 크기가 고정되어 있기 때문에, 페이지 폴트가 발생하면 프로세스 안에서 페이지 교체 정책을 통해 자체적으로 메모리를 확보한다.  

**특징:**
- 자신에게 할당된 frame 내에서만 replacement
- FIFO, LRU, LFU 등의 알고리즘을 process별로 운영

**동작:**
- 프로세스마다 메모리를 할당
- 자기에게 할당된 페이지 중에서만 쫓아냄

## 14. Thrashing

### 14.1 개념

프로세스들이 자신의 작업을 처리하지 못하고 페이지 폴트로 인한 페이지 교체, 혹은 프레임의 재할당 등을 하는 데 시간을 계속 투자하는 상황 

예를 들어, 현재 CPU의 Utiliztion이 낮을 때 운영체제는 CPU의 Utiliztion을 높이기 위해 더 많은 프로세스를 메모리에 불러들일 수 있다.  
하지만 CPU의 Utiliztion이 낮은 이유가 적은 수의 프로세스 때문이 아닌 프레임은 부족하고 프로세스는 많았기 때문(페이지 폴트가 계속 일어나는 상황)이라면 상황은 더 악화된다.  
 
<img src="images/image%2028.png" width="700">

**Thrashing:**
- 프로그램이 원활하게 실행되기 위해 필요한 최소한의 메모리도 얻지 못한 상황
- CPU는 놀고 있고 page fault 처리하느라 바쁜 상황
- 각 프로그램이 메모리를 너무 조금씩 가지고 있어서 누구에게 CPU를 줘도 page fault 발생

**Degree of Multiprogramming:**
- 메모리에 들어가 있는 프로그램의 개수
- 일반적으로 메모리에 여러 프로그램을 올려놓으면 CPU utilization이 높아짐
- 하지만 너무 많으면 Thrashing 발생

### 14.2 Thrashing 발생 과정

1. 프로세스가 원활한 수행에 필요한 최소 page frame 수를 할당받지 못함
2. Page fault rate이 매우 높아짐
3. CPU utilization이 낮아짐
4. OS는 MPD를 높여야 한다고 판단 (CPU가 노니까)
5. 또 다른 프로세스를 시스템에 추가 (higher MPD)
6. 프로세스당 할당된 frame 수가 더욱 감소
7. 프로세스는 page의 swap in/swap out으로 매우 바쁨
8. 대부분의 시간에 CPU는 한가함
9. Low throughput

**Thrashing을 막는 방법:**
- 프로그램에게 필요한 최소한의 메모리를 보장해줘야 함

## 15. Working-Set Model

### 15.1 Locality of Reference

**개념:**
- 프로세스는 특정 시간 동안 일정 장소만을 집중적으로 참조
- 집중적으로 참조되는 page들의 집합을 **locality set**이라 함

**예시:**
- 반복문 실행 중: 반복문 코드 페이지들만 집중 참조
- 함수 실행 중: 해당 함수 관련 페이지들만 집중 참조

### 15.2 Working-Set Model

**Working Set:**
- Locality에 기반하여 프로세스가 일정 시간 동안 원활하게 수행되기 위해 한꺼번에 메모리에 올라와 있어야 하는 page들의 집합

**동작 방식:**
- Process의 working set 전체가 메모리에 올라와 있어야 수행
- 그렇지 않으면 모든 frame을 반납한 후 swap out (suspend)
- Thrashing 방지
- Multiprogramming degree 결정

**MPD 조절 방법:**
- Working set을 보장받을 수 있는 프로그램만 메모리에 올림
- 메모리가 부족해서 working set이 보장 안 되는 프로세스는 swap out
- 메모리에 여유가 생기면 swap out된 프로세스를 다시 메모리에 올림

## 16. PFF (Page-Fault Frequency) Scheme

<img src="images/image%2029.png" width="700">

### 16.1 개념

Page fault rate의 상한값과 하한값을 설정

**동작:**
- Page fault rate이 상한값을 넘으면 → frame을 더 할당
- Page fault rate이 하한값 이하이면 → 할당 frame 수를 줄임
- 빈 frame이 없으면 일부 프로세스를 swap out

### 16.2 원리

각 프로세스의 page fault 비율을 수시로 보면서 페이지를 더 줄지 덜 줄지 결정한다.

**메모리 할당과 Page Fault의 관계:**
- 메모리를 너무 적게 주면 page fault가 많이 발생
- 메모리를 많이 주면 page fault가 적게 발생
- 메모리를 할당함에 따라 page fault 비율은 낮아지는 곡선

**목표:**
- Upper bound와 lower bound 사이에 오면 메모리를 더 이상 줄 필요 없다고 판단
- Page fault가 높으면 메모리를 더 주고, 너무 낮으면 메모리를 회수
