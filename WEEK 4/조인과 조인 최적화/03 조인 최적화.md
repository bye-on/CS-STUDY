# 03. 조인 최적화

## 1. 인덱스(Index) 전략

조인 최적화의 핵심 요소로, 인덱스 유무와 구성에 따라 성능 차이가 결정됨

### 1.1. 인덱스 생성

NL Join 수행 시 Driven Table(후행 테이블)의 조인 컬럼에 인덱스가 필수

- **인덱스 없음:** 선행 테이블의 행 수만큼 후행 테이블 전체를 스캔(**Full Scan**)하여 비효율적
- **인덱스 있음:** 인덱스를 통해 특정 데이터만 액세스(**Random Access**)하여 성능 향상

> Risks
> 
> - **DML 성능 저하:** 인덱스가 많아지면 `INSERT`, `UPDATE`, `DELETE` 시 인덱스도 갱신해야 하므로 쓰기 성능이 떨어짐
> - **용량 증가:** 인덱스도 물리적인 공간을 차지하므로 저장 공간 사용량 증가

### 1.2. 결합 인덱스 구성 순서

조인 조건(`ON`)뿐만 아니라 필터 조건(`WHERE`)까지 고려하여 인덱스를 구성해야 함

- **우선순위:** **Equal**조건이 되는 컬럼을 인덱스 선두에 배치
- **이유:** 필터링을 통해 데이터 범위를 먼저 줄인 후 조인을 시도해야 효율적

> Risks
> 
> - **범용성 감소:** 특정 쿼리에만 최적화된 결합 인덱스는 다른 쿼리에서는 사용되지 않을 수 있어 비효율적인 인덱스 개수만 늘릴 수 있음

### 1.3. 커버링 인덱스

쿼리에서 요구하는 **모든 컬럼이 인덱스에 포함**된 상태

- **효과:** 실제 테이블 액세스 없이 인덱스만 읽고 처리가 완료됨
- **장점:** **Random Access 부하가 제거**되어 획기적인 성능 개선 가능

> Risks
> 
> - **인덱스 크기 비대화:** `SELECT` 절의 컬럼이 많을 경우, 이를 다 포함하면 인덱스 사이즈가 너무 커져서 메모리 효율이 떨어짐

---

## 2. 조인 순서 제어

옵티마이저의 판단에만 의존하지 않고, 데이터 특성에 따라 선행 테이블을 결정해야 함

### 2.1. 작은 집합이 선행(Driving)

**작은 집합의 정의:** 테이블 전체 크기가 아닌, **WHERE 절로 필터링된 결과 건수**가 적은 집합

- **NL Join:** 선행 테이블의 건수가 **전체 루프 횟수**를 결정하므로, 적은 집합이 선행되어야 함
- **Hash Join:** 선행 테이블(Build Input)이 작아야 해시 테이블 생성 시 **메모리** 내에서 처리가 가능

### 2.2. 힌트(Hint) 사용

옵티마이저가 통계 정보 오류 등으로 비효율적인 계획을 수립할 때 강제 적용

- **Oracle 예시:** `/*+ LEADING(A) USE_NL(B) */`
- **MySQL 예시:** `STRAIGHT_JOIN`

> Risks
> 
> - **유지보수 어려움:** 데이터 분포가 변해도 힌트는 고정되어 있어, 나중에는 오히려 나쁜 실행 계획이 될 수 있음 (주기적인 점검 필요)
> - **버전 호환성:** DB 엔진 버전 업그레이드 시 힌트 동작 방식이 바뀌거나 무시될 수 있음

---

## 3. 조인 방식 선택

데이터의 양과 조건에 따라 적절한 조인 알고리즘으로 유도

### 3.1. NL Join 유도

- **상황:** 전체 데이터는 많으나, 필터링된 결과가 **소량**일 때
- **전략:** 인덱스를 활용한 **Random Access**로 빠르게 응답 결과 반환

> Risks
> 
> - **데이터 증가 시 성능 급락:** 초기에는 빨랐으나, 데이터가 쌓여 필터링 결과가 많아지면 Random Access 부하로 인해 시스템 전체가 느려질 수 있음 (Bad Scalability)

### 3.2. Hash Join 유도

- **상황:** 조인 대상 데이터가 **대량**일 때
- **전략:** NL Join의 Random Access 부하를 피하기 위해 **Hash Join** 사용

> Risks
> 
> - **메모리 부족:** Build Input이 메모리(`Hash Area`)보다 크면 디스크를 사용하게 되어 성능이 급격히 저하됨 (`Grace Hash Join` 발생)
> - **첫 응답 지연:** 해시 테이블을 다 만들 때까지 첫 번째 결과가 나오지 않음

### 3.3. Sort Merge Join 활용

- **상황:** **범위 검색**(`<`, `>`)이거나 이미 **정렬된 인덱스**가 있을 때

> Risks
> 
> - **정렬 부하:** 정렬된 인덱스가 없다면 정렬(`Sort`) 과정에서 CPU와 메모리를 과도하게 사용함

---

## 4. 데이터 모델링 변경

SQL 튜닝으로 해결되지 않는 구조적 문제일 때 고려

### 4.1. 반정규화

- **상황:** 잦은 조인으로 성능 저하 심각
- **해법:** 자주 조회되는 컬럼을 중복 허용하여 합침
- **효과:** 조인 연산 제거

> Risks
> 
> - **데이터 무결성 깨짐:** 원본 데이터가 변경되었을 때, 복제된 컬럼도 같이 수정해주지 않으면 데이터 불일치 발생
> - **갱신 비용 증가:** 데이터 수정 시 여러 테이블을 동시에 건드려야 함

### 4.2. 파티셔닝

- **상황:** 대용량 테이블 조인
- **해법:** 날짜나 특정 키 기준으로 분할 저장
- **효과:** **Partition Pruning**을 통해 스캔 범위 최소화

> Risks
> 
> - **Global Index 관리 비용:** 파티션 키 이외의 조건으로 조회하거나 조인할 때 인덱스 관리가 복잡하고 성능이 떨어질 수 있음
> - **파티션 키 선정 실패:** 파티션 키가 쿼리 조건에 포함되지 않으면 모든 파티션을 다 뒤져야 함