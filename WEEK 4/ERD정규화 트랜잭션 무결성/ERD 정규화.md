# ERD 정규화

# ERD(Entity Relationship Diagram)

- 릴레이션 간의 관계들을 정의함

# 정규화와 정규형

- 어떤 릴레이션 스키마가 주어지면, 스키마의 설계가 올바른지 아니면 여러 개의 더 작은 릴레이션들로 분해하여야 하는지 판단하여야 합니다.
- 이에 대한 판단 기준으로 정규형들이 제안되었으며, 해당 릴레이션이 어떤 정규형에 속하는지에 따라 어떤 문제를 일으킬 수 있는지 알 수 있습니다.

## 정규화(Normalization)

⇒ 데이터 중복을 줄이고 무결성을 유지하기 위해 ERD에서 정의된 엔터티와 관계를 더 세부적으로 분석하여 각 테이블의 구조를 개선하는 과정

- 릴레이션에 존재하는 속성간의 종속성으로 인한 이상 현상이 발생할 수 있는 경우를 방지하기 위해 릴레이션을 분해하여 이상현상을 없애는 과정
- 데이터의 중복 방지, 삽입, 삭제, 갱신 이상을 최소화하는, 즉 무결성을 충족하기 위한 데이터의 설계 방법
- 릴레이션 스키마가 어떤 정규형을 만족하는지 확인하는 테스트

**정규화 원칙**

→ 분해에 의한 정규화 과정은 릴레이션 스키마들이 함께 가져야 하는 추가적인 특성들을 만족하도록 해야함

- 무손실 법칙: 분해된 릴레이션이 표현하는 정보는 분해되기 전의 정보를 모두 포함
- 최소 데이터 중복 법칙: 이상 현상을 제거, 데이터 중복을 최소화
- 분리 법칙: 독립된 함수 종속은 독립된 릴레이션으로 분해

**장점**

- 이상 현상 해결
- 새 속성 추가시 데이터베이스 변경의 최소화
- 현실 세계의 개념간의 관게 표현

**비정규화 / 반정규화**

 더 높은 정규형 릴레이션들을 조인한 결과를 기본 릴레이션으로 저장하는 과정을 비정규화/반정규화(Denormalization)이라고 함

---

# **제 1정규형(First Normal Form)**

- 도메인의 원소들이 나눌 수 없는 단위로 되어 있을 때 그 도메인은 원자적(Atomic)이라고 함
- 어떤 릴레이션 R에 속한 모든 도메인이 원자적일 때 R은 제 1정규형(1NF)에 속함

<aside>

릴레이션 스키마 R의 모든 원소들의 도메인이 원자적일 때 R이 제 1정규형(1NF)에 속한다고 합니다. 

</aside>

아래 릴레이션과 같이 한 도메인이 여러 값을 포함하고 있을 때, 이 집합은 원자적이지 않습니다.

| **학번** | **지도교수** | **학과** | **과목번호** | **성적** |
| --- | --- | --- | --- | --- |
| 100 | 이순신 | 컴퓨터공학과 | C102, D103 | A, B |
| 200 | 홍길동 | 컴퓨터공학과 | C102 | B |
| 300 | 윤동주 | 기계공학과 | D102 | A |
| 400 | 김영랑 | 수학과 | F201 | C |

아래와 같이 릴레이션에 속한 모든 도메인이 원자적이면, 이 릴레이션은 제 1정규형에 속합니다.

| **학번** | **지도교수** | **학과** | **과목번호** | **성적** |
| --- | --- | --- | --- | --- |
| 100 | 이순신 | 컴퓨터공학과 | C102 | A |
| 100 | 이순신 | 컴퓨터공학과 | D103 | B |
| 200 | 홍길동 | 컴퓨터공학과 | C102 | B |
| 300 | 윤동주 | 기계공학과 | D102 | A |
| 400 | 김영랑 | 수학과 | F201 | C |

---

# **제 2정규형(Second Normal Form)**

- **완전 함수 종속** 개념에 기반을 둠
- 한 릴레이션이 1NF(제 1정규형)이고 기본 키에 속하지 않은 속성이 기본 키에 완전 함수 종속되는 경우

**완전 함수 종속(Full functional dependency)**

<aside>

함수 종속 X → Y에서

- X로부터 임의의 속성 A를 제거하면 X → Y가 성립되지 않는 경우
- 즉, 임의의 속성 A ∈ X에 대해서 Y가 (X {A})에 함수 종속하지 않는 경우
</aside>

제 2 정규형 검사는 함수 종속의 왼편의 속성들이 기본 키의 일부인지 검사하는 것을 수반함

만약 기본키가 단일 속성이라면 검사를 건너뛰어도 무방함. 

<aside>

릴레이션 스키마 R의 모든 속성이 R의 기본키에 대해서 완전 함수 종속이면 R을 제 2정규형(Second Normal Form - 2NF)이라고 합니다. 

</aside>

아래와 같은 릴레이션 스키마 Grade가 있고,

```
Grade(StudentNo, Professor, Department, SubjectID, Grade)
          S          P          D           J        G
```

릴레이션 인스턴스가 아래와 같다고 할 때,

| **StudentNo** | **Professor** | **Department** | **SubjectID** | **Grade** |
| --- | --- | --- | --- | --- |
| 100 | 이순신 | 컴퓨터공학과 | C102 | A |
| 100 | 이순신 | 컴퓨터공학과 | C103 | B |
| 200 | 홍길동 | 컴퓨터공학과 | C102 | B |
| 300 | 윤동주 | 기계공학과 | D102 | A |
| 400 | 김영랑 | 수학과 | F201 | C |

릴레이션 스키마 Grade는 아래와 같은 함수 종속을 가집니다.

<aside>

*FD1: S → PD*

*FD2: J → G*

</aside>

릴레이션 스키마가 제 2 정규형이 아니라면 여러 개의 제 2정규형 릴레이션으로 정규화 할 수 있음

속성이 완전 함수 종속관계가 있는 기본 키의 일부 속성들과만 연관되도록 구성됨

*Student(StudentNo, Professor, Department)* *Grade(StudentNo, Grade)*

| **StudentNo** | **Professor** | **Department** |
| --- | --- | --- |
| 100 | 이순신 | 컴퓨터공학과 |
| 200 | 홍길동 | 컴퓨터공학과 |
| 300 | 윤동주 | 기계공학과 |
| 400 | 김영랑 | 수학과 |

| **StudentNo** | **SubjectID** | **Grade** |
| --- | --- | --- |
| 100 | C102 | A |
| 100 | C103 | B |
| 200 | C102 | B |
| 300 | D102 | A |
| 400 | F201 | C |

---

## **제 3정규형(Third Normal Form)**

- 이행적 함수 종속(이행적 종속성, Transitive dependency) 개념에 기반
    - 릴레이션 스키마 R에서, 후보 키가 아니고 어떤 키의 부분집합도 아닌 속성 집합 Z가 있을 때,
    - X → Z와 Z → Y가 만족될 때, 함수 종속 X → Y를 이행적 함수 종속이라고 부름
- **Edgar F. Codd** 의 정의
    - 릴레이션 스키마 R이 2NF이고
    - R의 어떤 비주요 속성도 기본 키에 이행적으로 종속하지 않으면 R은 3NF에 속함
- 구분
    - R: 릴레이션 스키마, X: R에 속하는 릴레이션 인스턴스의 부분집합, A: R의 속성일 때
    - 다음 중 하나에 속하면 제 3 정규형에 속함
        - A ∈ X, 즉 평범한 함수 종속
        - X가 슈퍼키
        - A가 R의 어떤 키의 일부
    - 제 3차 정규형은 BCNF와 비슷하지만, 3번째 조건이 다릅니다.

**3NF를 위배하는 경우(어떤 종속성 X → A)**

1. **X는 어떤 키 K의 진부분집합 ⇒ 부분 종속성(Partial Dependency)** 
    - 이 경우에는 (X, A) 쌍 여러 개를 중복해서 저장하게 됩니다.

아래와 같이 항공편 번호, 승객 번호, 예약 일자, 신용카드 번호를 저장하는 릴레이션 스키마가 있을 때,

```
Reservation(FlightNo, PassengerNo, Date, CreditCardNo)
                F            P          D         C
```

릴레이션 Reservation에 키는 FPD 밖에 없고 함수 종속 P → C가 존재합니다. 

즉, 한 고객에 대한 신용카드 번호가 고객의 예약 수 만큼 존재하게 됩니다.

부분적 함수 종속

![image02](https://github.com/gikpreet/class-relational_database/raw/main/course/Module11_schema_refine_and_normal_form/images/image02.png)

1. **X는 어떤 키의 진부분집합도 아님 ⇒  이행적 함수 종속(Transitive Dependency)**
    - 이 경우에는 K → X → A라고 하는 연쇄적인 종속을 의미합니다.
    - 어떤 K 값에 어떤 X 값을 연관시킬 때에는 그 X값이 어떤 A값을 연관시켜 주어야 한다는 것입니다.

아래와 같은 릴레이션이 있을 때,

```
Parttime_emp(EmpID, Name, Parkingslot, Grade, WagePerHr, Workingtime)
                E     M       P          G        W           T
```

유일한 키는 E이고, 함수 종속 W → T가 존재하기 되므로 E → W → T라는 연쇄가 나타나게 됩니다. 

따라서 직원 E가 등급 G를 가진다는 것을 기록하려면 해당 등급에 해당하는 시간당 임금을 같이 삽입해야 합니다.

이로 인해 삽입 이상, 삭제 이상, 갱신 이상이 발생합니다.

이행적 함수 종속

![A가 키에 속하지 않는 경우](https://github.com/gikpreet/class-relational_database/raw/main/course/Module11_schema_refine_and_normal_form/images/image03.png)

+ A가 키에 속하는 경우

![A가 키에 속하는 경우](https://github.com/gikpreet/class-relational_database/raw/main/course/Module11_schema_refine_and_normal_form/images/image04.png)

**+a  3NF에서 발생할 수 있는 중복성 (↔ BCNF)**

3NF는 BCNF보다 조건이 느슨하기 때문에, **결정자가 키가 아니어도 종속성 A가 키의 일부이면 허용**한다.

그 결과 **일부 중복이 여전히 발생할 수 있다.**

아래 릴레이션 스키마에서,

```
Reservation(FlightNo, PassengerNo, Date, CreditCardNo)
                F          P         D         C
```

여기서 다음 함수 종속이 있다고 하자:

- **P → C** : 승객(P)은 항상 하나의 신용카드(C)를 사용한다.

<aside>

하지만, P는 키가 아니고, C도 키가 아니며, 전체 키는 **FPD이다.**

따라서 **P → C는 원래 3NF 위반**이다.

</aside>

- C → P가 추가되면 상황이 달라짐
    
    신용카드번호(C)가 승객(P)을 유일하게 식별한다고 하면,
    
    - **C → P**가 얻어진다면, **CDP**도 키가 될 수 있다.
    - 이제 P → C는 종속자가 키의 일부(C)이므로 **3NF에서는 허용된다.**

즉, 이 릴레이션은 **3NF에 속하게 된다.**

<aside>

그러나 여전히 중복 문제는 남는다.

</aside>

같은 FlightNo(F)를 가진 여러 튜플에서 (P, C) 쌍이 반복적으로 저장된다.

→ **3NF는 BCNF보다 약해서 이런 중복을 완전히 제거하지 못한다.**

---

# **Boyce-Code 정규형 (BCNF)**

- 제 3정규형보다 더 엄격한 정규형
- **모든 함수적 종속에서 결정자(`Determinant`)는 반드시 후보키(`Candidate Key`)여야 한다.**

**결정자**

- **결정자(`Determinant`)** 는 관계형 데이터베이스에서 **다른 속성의 값을 유일하게 결정짓는 속성 또는 속성들의 집합** 을 의미함
    - 어떤 속성 `A`가 속성 `B`를 함수적으로 결정할 때,
        - `A → B` 라고 표기하며,
        - 이때 `A`가 **결정자(`Determinant`)**, `B`는 **종속자(`Dependent`)** 라고 함
        

⇒ 즉, **같은 `A` 값을 가지면 항상 같은 `B` 값을 갖는다면 `A`는 `B`의 결정자**

**후보키**

- **후보키(`Candidate Key`)** 란 관계형 데이터베이스에서 **튜플(레코드)를 유일하게 식별할 수 있는 최소한의 속성(또는 속성 집합)**
- 즉, **유일성과 최소성** 을 만족하는 키

**후보키의 조건**

1. **유일성 (`Uniqueness`)**
    - 후보키에 해당하는 값은 테이블 내에서 **중복되지 않아야** 합니다.
2. **최소성 (`Minimality`)**
    - 후보키를 구성하는 속성 중 **어떤 것도 제거할 수 없어야** 합니다.
    - (즉, 최소한의 속성 집합이어야 함)

정의

- R: 릴레이션 스키마, X: R에 속하는 릴레이션 인스턴스의 부분집합, A: R의 속성일 때
- R이 만족하는 모든 함수 종속 X → A가 다음 중 하나에 속하면 BCNF에 속함
- A ∈ X, 즉 평범한 함수 종속
- X가 슈퍼키

후보 키가 여러 개라면 후보 키 하나가 키의 역할을 담당한다.

함수 종속 정보만 아는 경우에는 중복성의 관점에서 볼 때 BCNF가 가장 바람직한 정규형이 됨.

| **X** | **Y** | **A** |
| --- | --- | --- |
| x | y1 | a |
| x | y2 | ? |

여기서 **함수 종속 X → A**가 성립한다는 것은 **X 값이 같으면 A 값도 항상 같아야 한다**는 의미이다.

따라서 첫 번째 투플에서 `X = x`일 때 `A = a`이므로, 두 번째 투플에서도 `A`의 값은 반드시 **a**가 되어야 한다.

<aside>

즉, 두 번째 투플의 A 값은 실제로 저장해야 하는 정보가 아니라 함수 종속 규칙을 통해 **자동으로 결정되는 값**이 되어 데이터 중복이 발생하게 된다.

BCNF에서는 이런 중복이 나타나지 않도록 **결정자 X가 후보키가 아니면 안 된다**는 규칙을 적용한다.

</aside>

이미 있는 다른 속성들로부터 자동으로 결정되는 값이 테이블에 저장되어 있어서는 안 된다.

BCNF에서는 저절로 결정되는(=종속되는) 값이 테이블에 남아 있는 구조 자체가 존재할 수 없다.

```
Parttime_emp(EmpID, Name, Parkingslot, Grade, WagePerHr, Workingtime)
               E     M         P         G        W            T
```

`Parttime_emp(E, M, P, G, W, T)` 릴레이션에는 다음 두 함수 종속이 있다:

1. **E → 모든 속성(EMPGWT)**
    
    → EmpID가 전체 튜플을 식별하므로 E는 키이다.
    
2. **G → W**
    
    → Grade가 시급(Wage)을 결정한다.
    

<aside>

문제는 **G가 테이블 전체를 식별하는 키가 아니라는 점**이다.

하지만 G가 W를 결정하고 있으므로, 키가 아닌 속성이 다른 속성을 결정”하는 형태가 된다.

</aside>

문제를 해결하기 위해 테이블을 두 개로 나누면 된다.

1. **EMPGT 테이블(E, M, P, G, T)**
    - 여기서는 **E가 모든 속성을 결정(E → EMPGT)**
    - E가 키이므로 **BCNF 만족**
2. **GW 테이블(G, W)**
    - 여기서는 **G가 W를 결정(G → W)**
    - G가 키이므로 **BCNF 만족**

이렇게 분해하면

각 테이블에서 결정자는 모두 키가 되므로

**두 테이블은 모두 BCNF가 된다.**