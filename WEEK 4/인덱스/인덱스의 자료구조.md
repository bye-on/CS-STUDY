## 2. 인덱스의 자료구조 (Hash Index, B Tree)

### Hash Index

해시 함수를 사용하여 키-값 쌍으로 데이터를 저장하는 인덱스다.

![image.png](./images/image%204.png)

**동작 방식**

'john smith'가 컬럼의 값이라면:
1. 해시 함수를 거쳐 '02'라는 해시값을 얻는다
2. 02번 버킷(배열)에서 실제 데이터의 위치를 얻는다

**배열 순차 탐색 방식**
```
keys[] 배열을 순차 탐색 → John Smith 찾음 → 해당 위치로 이동
```
시간복잡도: O(n)

**해시 인덱스 방식**
```
hash("John Smith") = 02
→ bucket[02] 바로 접근
→ rowid 바로 얻음
```
시간복잡도: O(1)

key를 탐색하는 과정 자체가 없기 때문에 속도가 매우 빠르다.

**장점**
- 등호(=) 비교 검색에서 O(1)의 매우 빠른 속도
- 정확한 값을 찾을 때 B-Tree보다 빠름

**단점**
- 범위 검색(>, <, BETWEEN) 불가능
- 정렬(ORDER BY) 불가능
- 부분 일치 검색(LIKE) 불가능
- 해시 충돌(Hash Collision) 가능성

```sql
-- Hash Index에 적합: 정확한 값 검색
SELECT * FROM users WHERE user_id = 12345;

-- Hash Index에 부적합: 범위 검색
SELECT * FROM users WHERE age > 20 AND age < 30;  -- B-Tree 필요
```

**왜 데이터베이스는 Hash Index를 주로 사용하지 않는가?**

해시 함수는 값이 1이라도 달라지면 완전히 다른 해시값을 생성한다.  
이러한 특성 때문에 부등호 연산(>, <, >=, <=)이 자주 사용되는 데이터베이스 검색에는 해시 테이블이 적합하지 않다.  
따라서 데이터베이스의 인덱스에서는 B+Tree가 일반적으로 사용된다.  

### B-Tree의 기본 원리: 이진 탐색 트리(BST)에서 시작

B-Tree를 이해하려면 먼저 이진 탐색 트리(Binary Search Tree)를 알아야 한다.

**이진 탐색 트리(BST)의 규칙**

- 모든 노드의 왼쪽 서브트리는 해당 노드의 값보다 작은 값들만 가진다
- 모든 노드의 오른쪽 서브트리는 해당 노드의 값보다 큰 값들만 가진다
- 자녀 노드는 최대 2개까지 가질 수 있다

![image.png](./images/image%207.png)

부모 노드의 값이 K1이라면:
- 왼쪽 자식: 값 < K1
- 오른쪽 자식: K1 < 값

### B-Tree로의 확장

자녀를 3개 이상 두려면 어떻게 해야 할까?

- 왼쪽 자식: 값 < K1
- 가운데 자식: K1 < 값 < K2
- 오른쪽 자식: K2 < 값

이렇게 구성하려면 부모 노드에 K1과 K2, 즉 2개의 값이 저장되어야 한다.

![image.png](./images/image%208.png)

**B-Tree의 핵심 특징**

- 자녀 노드의 최대 개수를 늘리기 위해 부모 노드에 key를 하나 이상 저장한다
- 부모 노드의 key들을 오름차순으로 정렬한다
- 정렬된 순서에 따라 자녀 노드들의 key 값 범위가 결정된다
- B-Tree는 BST를 일반화한 트리라고 할 수 있다
- 자녀 노드의 최대 개수를 필요에 따라 결정할 수 있다

### B-Tree의 파라미터

![image.png](./images/image%209.png)

- **M**: 각 노드의 최대 자녀 노드 수
  - 최대 M개의 자녀를 가질 수 있는 B-Tree를 **M차 B-Tree**라 부른다
- **M-1**: 각 노드의 최대 key 수
- **⌈M/2⌉**: 각 노드의 최소 자녀 노드 수 (올림 처리)
  - root node, leaf node는 제외
  - 예: M=3이면 ⌈3/2⌉=2
- **⌈M/2⌉-1**: 각 노드의 최소 key 수
  - root node는 제외
- 노드의 key 수가 x개라면 자녀 노드의 수는 언제나 x+1개다
- 노드가 최소 하나의 key는 가지기 때문에 몇 차 B-Tree인지와 상관없이 internal 노드는 최소 2개의 자녀를 가진다

**예시**: 5차 B-Tree라면 root 노드를 제외한 모든 internal 노드는 ⌈5/2⌉=3, 즉 최소 3개의 자녀 노드를 가져야 한다.  

```
        [루트 노드]
       /     |     \
  [브랜치]  [브랜치]  [브랜치]
   /  \      /  \      /  \
[리프][리프][리프][리프][리프][리프]
```

**구성 요소**
- **루트 노드(Root Node)**: 트리의 최상단 노드, 탐색의 시작점
- **브랜치 노드(Branch Node)**: 중간 노드, 데이터 범위를 나누는 역할
- **리프 노드(Leaf Node)**: 최하단 노드, 실제 데이터의 위치(포인터)를 저장

### B-Tree 탐색 과정

![image.png](./images/image%205.png)

1. 루트 노드에서 시작
2. 찾고자 하는 값과 비교하여 적절한 브랜치로 이동
3. 리프 노드에 도달할 때까지 반복
4. 리프 노드에서 실제 데이터의 위치를 확인

**주의사항**: 읽어야 할 레코드 건수가 전체 테이블 레코드의 20~25%를 넘으면 인덱스를 이용하지 않는 것이 더 효율적이다.  

### B-Tree가 효율적인 이유

**1) 균형 잡힌 트리 구조**

- 모든 리프 노드가 같은 깊이에 위치
- 어떤 데이터를 찾더라도 동일한 단계를 거침
- 최악의 경우에도 일정한 성능 보장

**2) 대수확장성 (Logarithmic Scalability)**

트리의 깊이가 데이터 수에 비해 매우 느리게 증가하는 특성을 가진다.

| 트리 깊이 | 최대 레코드 수 | 비고 |
|---------|------------|------|
| 1 | 4 | 4¹ |
| 2 | 16 | 4² |
| 3 | 64 | 4³ |
| 4 | 256 | 4⁴ |
| 5 | 1,024 | 4⁵ |
| 10 | 1,048,576 | 4¹⁰ (약 100만 개) |

**핵심**: 깊이가 10단계만 있어도 100만 개 이상의 레코드를 검색할 수 있다. 즉, 100만 개의 데이터 중에서 원하는 값을 찾는데 최대 10번의 비교만 필요하다.

### B-Tree 데이터 삽입

**삽입 규칙**

- 추가는 항상 leaf 노드에 한다
- 노드가 넘치면 가운데 key를 기준으로 좌우 key들을 분할하고 가운데 key는 승진한다
  - 노드가 넘친다: M차 B-Tree에서 각 노드가 가질 수 있는 최대 key 수(M-1)보다 key의 수가 많은 경우

**예시: 3차 B-Tree 데이터 삽입**

여기에 2를 추가하면:  

![image.png](./images/image%2011.png)  

노드가 넘쳤다 (3차 B-Tree는 최대 2개의 key만 가질 수 있음)

![image.png](./images/image%2012.png)  

2를 기준으로 1과 15를 분할하고 2는 승진한다.

![image.png](./images/image%2013.png)

30을 추가:  

![image.png](./images/image%2014.png)

![image.png](./images/image%2015.png)

15를 기준으로 5와 30을 분할하고 15는 승진한다.  

![image.png](./images/image%2016.png)

90을 추가:

![image.png](./images/image%2017.png)

30을 기준으로 20과 90이 분할되고 30이 승진:

![image.png](./images/image%2018.png)

15를 기준으로 2와 30이 분할되고 15는 승진:

![image.png](./images/image%2019.png)

**결과**: 모든 leaf 노드들이 같은 레벨에 있다 → **Balanced Tree**

![image.png](./images/image%2020.png)

검색 시간복잡도: 평균/최악 모두 O(log N)

### B-Tree 데이터 삭제

**삭제 규칙**

- 삭제도 항상 leaf 노드에서 발생
- 삭제 후 최소 key 수보다 적어졌다면 재조정한다

**재조정 방법**

1. **key 수가 여유 있는 형제의 지원을 받는다**
   
   a. 왼쪽 형제(동생)가 여유가 있으면:
   - 동생의 가장 큰 key를 부모 노드의 나와 동생 사이 위치로 올린다
   - 원래 그 자리에 있던 부모의 key는 나의 가장 왼쪽에 둔다
   
   b. 오른쪽 형제(형)가 여유가 있으면:
   - 형의 가장 작은 key를 부모 노드의 나와 형 사이 위치로 올린다
   - 원래 그 자리에 있는 부모의 key는 나의 가장 오른쪽에 둔다

2. **1번이 불가능하면 부모의 지원을 받고 형제와 합친다**

3. **2번 후 부모에 문제가 있다면 재조정한다**
   
   a. 부모가 root 노드가 아니라면:
   - 그 위치에서부터 다시 1번부터 재조정을 시작한다
   
   b. 부모가 root 노드이고 비어있다면:
   - 부모 노드를 삭제한다
   - 직전에 합쳐진 노드가 root 노드가 된다

**예시: 3차 B-Tree 데이터 삭제**

![image.png](./images/image%2021.png)

**6 삭제:**

![image.png](./images/image%2022.png)

해당 노드의 key 수가 최소 key 수(1개)를 만족한다 → 재조정 불필요

**5 삭제:**

![image.png](./images/image%2023.png)

최소 key 수(1개)를 만족하지 않는다.

1. key 수가 여유 있는 형제의 지원을 받는다

왼쪽 노드를 우선으로 지원받는다. 왼쪽 노드의 key를 직접 오른쪽으로 옮길 수 없으므로 (부모 노드보다 작기 때문에):
- 왼쪽 노드의 key를 부모 노드로 승진시킨다
- 부모 노드의 key를 현재 노드로 내린다

![image.png](./images/image%2024.png)

**3 삭제:**

![image.png](./images/image%2025.png)

최소 key 수(1개)를 만족하지 않는다.

왼쪽 노드에 여유가 없으므로 오른쪽 노드의 지원을 받는다:

![image.png](./images/image%2026.png)

**7 삭제:**

![image.png](./images/image%2027.png)

형제의 지원이 불가능하므로 부모의 지원을 받고 형제와 합친다:

![image.png](./images/image%2028.png)

**1 삭제:**

![image.png](./images/image%2029.png)

![image.png](./images/image%2030.png)

부모가 지원한 후 부모에 문제가 생김:

![image.png](./images/image%2031.png)

부모가 root 노드이고 비어있으므로 삭제하고, 합쳐진 노드가 새로운 root가 된다:

![image.png](./images/image%2032.png)

### B+Tree

B+Tree는 B-Tree의 개선된 버전으로, 실제 데이터베이스에서 가장 많이 사용되는 구조다.

![image.png](./images/image%2033.png)

### B+Tree의 특징

**데이터 저장 방식**

- 데이터를 노드마다 보관하는 것이 아니라 **리프 노드에만 저장**한다
- 루트와 브랜치 노드에는 **가이드(키)와 포인터만 제공**한다
- 리프 노드끼리 연결 리스트로 연결되어 있다

**B-Tree와의 차이점**

- 리프 노드끼리 포인터로 연결되어 있다
- 이로 인해 **범위 검색이 매우 효율적**이다
- 리프 노드가 아닌 노드에는 실제 데이터가 아닌 인덱스 정보만 들어있다

**범위 검색의 효율성**

예를 들어 age가 4~8까지인 데이터를 찾는다면:

1. 4를 찾은 후
2. 포인터를 따라 다음 노드로 순차적으로 이동하면 된다
3. B-Tree에 비해 매우 간편하고 빠르다

![image.png](./images/image%2034.png)

### B-Tree vs B+Tree 비교

**B-Tree 장점**
- 내부 노드에서도 데이터를 찾을 수 있어 검색 깊이가 줄어들 수 있음
- 운이 좋으면 리프 노드까지 가지 않고 데이터를 찾을 수 있음

**B+Tree 장점**
- 리프 노드만 데이터 저장 → 내부 노드는 더 많은 키를 저장 가능 → **트리 높이가 낮아짐**
- 리프 노드끼리 연결 리스트 → **범위 검색 / 순차 탐색에 최적화**
- 일관된 검색 성능 (항상 리프 노드까지 탐색)

| **요소** | **B-Tree** | **B+Tree** |
|---------|-----------|-----------|
| **루트/브랜치 노드 구성** | **검색 키 (Key)** + **데이터 (Value)** + **자식 노드 포인터** | **검색 키 (Key)** + **자식 노드 포인터** (데이터 없음) |
| **핵심 차이** | 모든 노드가 데이터를 가질 수 있어 중간에 탐색이 끝날 수 있음 | 중간 노드는 인덱스 역할만 하고, 반드시 리프 노드까지 가야 데이터 획득 가능 |

### B-Tree 계열이 Self-Balancing BST보다 데이터베이스에 적합한 이유

B-Tree와 Self-Balancing BST(AVL Tree, Red-Black Tree 등) 모두 시간복잡도가 O(log N)인데, 왜 데이터베이스는 B-Tree 계열을 사용할까?

**Self-Balancing BST (AVL Tree, Red-Black Tree 등)**
- 스스로 균형을 잡는 이진 트리
- 메모리에서 동작할 때는 매우 효율적

![image.png](./images/image%2035.png)

![image.png](./images/image%2036.png)

**Secondary Storage의 특성**

Secondary Storage(하드디스크, SSD)는 데이터를 처리하는 속도가 가장 느리다. 따라서 DB에서 데이터를 조회할 때 Secondary Storage에 최대한 적게 접근하는 것이 성능 면에서 좋다.

또한 블록 단위로 읽고 쓰기 때문에 연관된 데이터를 모아서 저장하면 더 효율적으로 읽고 쓸 수 있다.

**접근 횟수 비교**

Root 노드를 제외한 모든 노드는 Secondary Storage에 있다고 가정하면:

![image.png](./images/image%2037.png)

![image.png](./images/image%2038.png)

AVL Tree는 4번 접근, B-Tree는 2번 접근하게 된다.

![image.png](./images/image%2039.png)

**핵심 차이**
- B-Tree: 자녀 노드 수 3~5개 (또는 그 이상)
- AVL Tree: 자녀 노드 수 1~2개

→ B-Tree는 데이터를 찾을 때 탐색 범위를 빠르게 좁힐 수 있다
→ Secondary Storage 접근 횟수가 적어 실제 성능이 훨씬 우수하다

## 핵심 요약  

### 자료구조
- **Hash Index**: 등호 비교에 최적화, 범위 검색 불가
- **B+Tree**: 범위 검색과 정렬에 최적화, 데이터베이스의 표준
- B+Tree가 데이터베이스에서 가장 많이 사용되는 이유는 **Secondary Storage 접근 횟수를 최소화**하기 때문
