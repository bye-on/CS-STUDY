## 3. 인덱스의 종류와 특징

### 클러스터형 인덱스 (Clustered Index)

![image.png](./images/image%2040.png)

**특징**

- 테이블당 **1개만** 생성 가능
- 실제 데이터가 인덱스 순서대로 **물리적으로 정렬**되어 저장됨
- 인덱스 자체가 데이터를 포함 (책의 내용 자체가 정렬된 것과 같음)
- Primary Key를 생성하면 자동으로 클러스터형 인덱스 생성
- 테이블 자체가 하나의 거대한 인덱스

**장점**

- 검색 속도가 매우 빠름 (특히 범위 검색)
- 데이터 접근 시 추가 탐색 불필요
- 물리적으로 정렬되어 있어 순차 I/O 발생

**단점**

- 데이터 삽입/수정/삭제 시 물리적 재정렬이 필요하여 느림
- 테이블당 1개만 생성 가능
- 페이지 분할(Page Split)이 발생할 수 있음

**예시**

```sql
-- MySQL에서 Primary Key는 자동으로 Clustered Index
CREATE TABLE users (
    user_id INT PRIMARY KEY,  -- 클러스터형 인덱스
    name VARCHAR(50),
    email VARCHAR(100)
);
```

### 보조 인덱스 (Secondary Index / Non-Clustered Index)

![image.png](./images/image%2041.png)

**특징**

- 테이블당 **여러 개** 생성 가능
- 별도의 공간에 인덱스 구조를 생성
- 인덱스는 데이터의 위치(포인터)만 저장
- 실제 데이터는 원래 위치에 그대로 유지
- 책의 색인과 같은 개념

**동작 과정**

1. 보조 인덱스에서 검색 키로 탐색
2. 해당 데이터의 위치(포인터) 확인
3. 실제 테이블에서 데이터 조회 (2단계 탐색)

**장점**

- 여러 개 생성 가능
- 데이터 삽입/수정/삭제가 클러스터형보다 빠름
- 다양한 검색 조건에 대응 가능

**단점**

- 2번 탐색해야 함 (인덱스 → 실제 데이터)
- 추가 저장 공간 필요
- 클러스터형보다 검색 속도가 느림

**예시**

```sql
-- 보조 인덱스 생성
CREATE INDEX idx_email ON users(email);
CREATE INDEX idx_name ON users(name);
-- 여러 개 생성 가능
```

## 4. 인덱스 설계 및 사용 시 고려사항

### 인덱스의 비용

**읽기 비용**

```
인덱스 없음: 테이블 직접 조회 (1번)
인덱스 있음: 인덱스 조회 + 테이블 조회 (2번)
```

- 보조 인덱스는 2번의 탐색을 수행해야 함
- 조회할 데이터가 많으면 인덱스가 오히려 비효율적일 수 있음
- 일반적으로 전체 데이터의 20~25% 이상을 조회하면 Full Scan이 더 빠름

**쓰기 비용**

데이터를 삽입/수정/삭제할 때마다:

1. 실제 테이블 수정
2. 인덱스도 함께 수정
3. B-Tree 균형 조정 (Rebalancing)
4. 데이터 재분산

```sql
-- 인덱스가 3개 있는 테이블에 INSERT
INSERT INTO users VALUES (...);
-- 실제로는 4번의 작업 발생 (테이블 1번 + 인덱스 3번)
```

### 인덱스 최적화 원칙

**1) 인덱스는 비용이다**

- 모든 컬럼에 인덱스를 만들지 말 것
- 인덱스 자체가 저장 공간을 차지함 (약 10%)
- 쓰기 작업 성능을 저하시킴

**나쁜 예시**

```sql
-- 모든 컬럼에 인덱스 생성 (비효율적!)
CREATE INDEX idx1 ON users(name);
CREATE INDEX idx2 ON users(age);
CREATE INDEX idx3 ON users(gender);
CREATE INDEX idx4 ON users(city);
CREATE INDEX idx5 ON users(phone);
```

**2) 항상 테스팅하라**

서비스 특성에 따라 최적의 인덱스는 다르다.

```sql
-- MySQL에서 쿼리 실행 계획 확인
EXPLAIN SELECT * FROM users WHERE email = 'test@example.com';

-- 실행 계획 분석 항목
-- - type: 접근 방식 (ALL < index < range < ref < const 순으로 좋음)
-- - possible_keys: 사용 가능한 인덱스
-- - key: 실제 사용된 인덱스
-- - rows: 검사할 예상 행 수
-- - Extra: 추가 정보 (Using index = 커버링 인덱스)
```

**3) 인덱스 사용이 적합한 경우**

**사용해야 할 때**
- 데이터가 충분히 많은 테이블 (최소 수만 건 이상)
- `SELECT` 조회가 빈번한 테이블
- `WHERE`, `ORDER BY`, `JOIN`에 자주 사용되는 컬럼
- 중복 값이 적은 컬럼 (높은 카디널리티)
- 범위 검색이 자주 발생하는 컬럼

**사용하지 않아야 할 때**
- 데이터가 적은 테이블 (수천 건 이하)
- `INSERT`, `UPDATE`, `DELETE`가 빈번한 테이블
- 중복 값이 많은 컬럼 (낮은 카디널리티)
- 조회 시 전체 데이터의 상당 부분(20~25% 이상)을 가져오는 경우

**낮은 카디널리티에서 인덱스가 비효율적인 이유**

성별(gender) 컬럼을 예로 들면:

- 값이 'male', 'female' 2가지만 존재
- 100만 건의 데이터 중 50만 건이 'male'
- 인덱스를 사용해도 결국 50만 건을 모두 확인해야 함
- 이 경우 인덱스를 사용하나 Full Scan을 하나 큰 차이가 없음
- 오히려 인덱스 조회 + 테이블 조회로 2번 탐색하여 더 느릴 수 있음

**4) 인덱스 개수 제한**

- 일반적으로 **테이블당 3~5개 이하** 권장
- 너무 많은 인덱스는 쓰기 성능을 크게 저하시킴
- 실제 사용되지 않는 인덱스는 제거할 것

**5) 인덱스 설계 체크리스트**

```sql
-- ✅ 좋은 인덱스 설계 예시
CREATE TABLE orders (
    order_id INT PRIMARY KEY,           -- 클러스터형 인덱스 (자동)
    user_id INT,
    order_date DATETIME,
    status VARCHAR(20),
    total_amount DECIMAL(10,2)
);

-- 자주 사용되는 조회 패턴 분석
-- 1. 특정 사용자의 주문 조회
-- 2. 날짜 범위로 주문 검색
-- 3. 상태별 주문 통계

-- 복합 인덱스 생성 (같음 > 정렬 > 범위 순서)
CREATE INDEX idx_user_date ON orders(user_id, order_date);
-- user_id는 등호 비교, order_date는 정렬/범위 검색에 사용

CREATE INDEX idx_status_date ON orders(status, order_date);
-- status별 통계 및 날짜 범위 검색에 사용
```

---

## 5. 실무 인덱스 관리 전략

인덱스 관리는 단계별 접근이 필요하다:

### 1단계: 모니터링
- 느린 쿼리 로그(Slow Query Log) 분석
- 자주 실행되는 쿼리 패턴 파악
- 응답 시간이 긴 쿼리 식별

```sql
-- MySQL 느린 쿼리 로그 활성화
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;  -- 1초 이상 걸리는 쿼리 기록
```

### 2단계: 분석
- EXPLAIN으로 실행 계획 확인
- 인덱스 사용 여부 확인
- Full Table Scan 발생 여부 확인

```sql
EXPLAIN SELECT * FROM orders 
WHERE user_id = 123 AND order_date > '2024-01-01';
```

### 3단계: 설계
- 자주 사용되는 쿼리 패턴에 맞는 인덱스 설계
- 복합 인덱스 순서 결정 (같음 > 정렬 > 범위)
- 카디널리티 고려

### 4단계: 테스트
- 운영 환경과 유사한 데이터로 성능 측정
- 인덱스 생성 전후 비교
- 쓰기 성능 영향 확인

### 5단계: 적용
- 서비스 영향을 최소화하는 시간대에 인덱스 생성
- 온라인 DDL 활용 (가능한 경우)

```sql
-- MySQL 온라인 인덱스 생성 (5.6 이상)
CREATE INDEX idx_user_date ON orders(user_id, order_date) ALGORITHM=INPLACE;
```

### 6단계: 지속적 모니터링
- 인덱스 사용률 확인
- 성능 개선 여부 확인
- 불필요한 인덱스 제거

```sql
-- 사용되지 않는 인덱스 확인 (MySQL 8.0)
SELECT * FROM sys.schema_unused_indexes;
```

## 핵심 요약  

### 인덱스 종류
- **클러스터형 인덱스**: 테이블당 1개, 물리적 정렬, Primary Key
- **보조 인덱스**: 테이블당 여러 개, 논리적 정렬, 추가 조회 필요

### 관리 전략
- 지속적인 모니터링과 최적화 필요
- 사용되지 않는 인덱스는 제거
- 정기적인 인덱스 재구축으로 단편화 해소
